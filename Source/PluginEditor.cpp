/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
BitCrusherAudioProcessorEditor::BitCrusherAudioProcessorEditor (BitCrusherAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p), gainSlider("gain"), effectSlider("effect")
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (400, 300);
    
    //Set our slider parameters and register ourselves as a listened
    effectSlider.setTextBoxStyle(Slider::NoTextBox, false, 0, 0);
    effectSlider.setSliderStyle(Slider::Rotary);
    effectSlider.setRange(0.1, 1.0);
    effectSlider.addListener(this);
    //Add the slider as a child component of this component and make it visible
    addAndMakeVisible(effectSlider);
    
    //Set our slider parameters and register ourselves as a listened
    gainSlider.setTextBoxStyle(Slider::NoTextBox, false, 0, 0);
    gainSlider.setSliderStyle(Slider::Rotary);
    gainSlider.setRange(0.0, 1.0);
    gainSlider.addListener(this);
    //Add the slider as a child component of this component and make it visible
    addAndMakeVisible(gainSlider);
    
    // Manually call the timerCallback() once so that the sliders and UI updates
    // before the window is open. This is a trick.
    timerCallback();
    // Start the timer which will be called (roughly) at 30Hz
    startTimer(30);
}

BitCrusherAudioProcessorEditor::~BitCrusherAudioProcessorEditor()
{
}

//==============================================================================
void BitCrusherAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);

    g.setColour (Colours::black);
    g.setFont (15.0f);
    g.drawFittedText ("Bit Crushing Baby!!!", getLocalBounds(), Justification::centred, 1);
}

void BitCrusherAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
    gainSlider.setBounds(10, 10, 60, 60);
    effectSlider.setBounds(100,10,60,60);
    
}

void BitCrusherAudioProcessorEditor::timerCallback(){
    // Update the slider's value polling from the gainParam in our processor
    // whenever this callback gets called. This is to make sure the GUI updates
    // when automation is drawn in the host. However, because of this, we DO NOT
    // send a change notification that the slider updated, because that would call
    // sliderValueChanged, which tells the host to update, creating a feedback look.
    gainSlider.setValue(processor.gainParam->getValue(), dontSendNotification);
    effectSlider.setValue(processor.effectParam->getValue(), dontSendNotification);
}

void BitCrusherAudioProcessorEditor::sliderValueChanged (Slider* sliderThatHasChanged){
    
    // Test which slider was updated (if more than one), and then update our processor
    // THROUGH THE HOST. This keep automation lanes in sync with us.
    if (sliderThatHasChanged == &gainSlider) {
        processor.gainParam->beginChangeGesture();
        processor.gainParam->setValueNotifyingHost(sliderThatHasChanged->getValue());
        processor.gainParam->endChangeGesture();
    }
    
    else if (sliderThatHasChanged == &effectSlider) {
        processor.effectParam->beginChangeGesture();
        processor.effectParam->setValueNotifyingHost(sliderThatHasChanged->getValue());
        processor.effectParam->endChangeGesture();
    }
    
}
